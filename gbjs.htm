<!doctype html><meta charset=utf-8>

<pre id=out></pre>

<script>


const MEM = new Uint8Array(65536);

function readMem(addr){return MEM[addr];}
function readMem16(addr){return [MEM[addr+1],MEM[addr]]}
function writeMem(addr, data){ MEM[addr] = data;}
function writeMem16(addr, dataH, dataL){ MEM[addr] = dataL; MEM[addr+1] = dataH;}

const REG = new Uint8Array(8);

const FLAGS = {
  Z:false,
  N:false,
  H:false,
  C:false
}

var PC = 0

var SP = 0

var EnableInterrupts = false



const A = 0b111
const B = 0b000
const C = 0b001
const D = 0b010
const E = 0b011
const H = 0b100
const L = 0b101

const HL = 0b110

const Immediate = 257
const BC = 258
const DE = 259
const SPr = 260

const opcodes = Array(256);
for (var i=0;i<256;i++) opcodes[i]=function(){ throw Error("Undefined Opcode" )};

const CBcodes = Array(256);
for (var i=0;i<256;i++) CBcodes[i]=function(){ throw Error("Undefined 0xCB Opcode" )};


function ld(a,b){ 

  if (b==Immediate) return function(){
    REG[a] = MEM[ PC+1 ];
    PC+=2
  }

  return function(){
    REG[a] = REG[b];
    PC++
  }
}
function ld_from_mem(a, b, c){
  if (b==Immediate) return function(){
    REG[a] = readMem( MEM[ PC+1 ] + (MEM[ PC+2 ] <<8) )
    PC+=3
  }

  return function(){
    REG[a] = readMem( (REG[b]<<8)+REG[c] );
    PC++
  }
}

function ld_to_mem(a, b, c){
  if (a==Immediate) return function(){
    writeMem( MEM[ PC+1 ] + (MEM[ PC+2 ] <<8), REG[b] )
    PC+=3
  }
  if (c==Immediate) return function(){
    writeMem( (REG[a]<<8)+REG[b] , MEM[PC+1] );
    PC+=2
  }
  return function(){
    writeMem( (REG[a]<<8)+REG[b] , REG[c] );
    PC++
  }
}

// Messy...
function ld16(a,b,c){
  
  
//  if (a==Immediate) return function(){
//    // HL into mem
//    writeMem16( MEM[ PC+1 ] + (MEM[ PC+2 ] <<8), REG[H], REG[L] )
//    PC+=3
//  }
  if (b==Immediate) {

    if (a==HL) return function(){
      // mem to hl
      REG[L] = readMem(MEM[ PC+1 ] + (MEM[ PC+2 ]<<8))
      REG[H] = readMem(MEM[ PC+1 ] + (MEM[ PC+2 ]<<8) + 1)

      PC+=3
    }

    // immediate into SP... 
    return function(){
      SP = MEM[ PC+1 ] + (MEM[ PC+2 ] <<8)
      PC+=3
    }

  }
  if (c==Immediate) return function(){
    
    REG[a] = MEM[ PC+2 ]
    REG[b] = MEM[ PC+1 ]

    PC+=3
  }

  // ld sp, hl
  return function(){
    SP = (REG[H]<<8) + REG[L]
    PC++
  }
}

function ldd(a,b){ //load with decrement
  if (a==HL) return function(){
    writeMem( (REG[H]<<8)+REG[L] , REG[A] );

    if (REG[L]==0) REG[H]--;
    REG[L]--;
    
    PC++
  }

  return function(){
    REG[A] = readMem( (REG[H]<<8)+REG[L] );

    if (REG[L]==0) REG[H]--;
    REG[L]--;

    PC++
  }

}
function ldi(a,b){ //load with increment
  if (a==HL) return function(){
    writeMem( (REG[H]<<8)+REG[L] , REG[A] );
    
    if (REG[L]==255) REG[H]++;
    REG[L]++;
    
    PC++
  }

  return function(){
    REG[A] = readMem( (REG[H]<<8)+REG[L] );

    if (REG[L]==255) REG[H]++;
    REG[L]++;

    PC++
  }

}

function ldc(a,b){
  if (a==A) return function(){ //LD   A, (FF00+C)
    REG[A] = readMem( 0xFF00 + REG[C] )
    PC++
  }
  return function(){ //LD   (FF00+C),A
    writeMem(0xFF00 + REG[C], REG[A])
    PC++
  }
}
function ldh(a,b){
  if (a==A) return function(){ //LD   A, (FF00+n)
    REG[A] = readMem( 0xFF00 + MEM[PC+1] )
    PC+=2
  }
  return function(){ //LD   (FF00+n),A
    writeMem(0xFF00 + MEM[PC+1], REG[A])
    PC+=2
  }
}


function ALU(op, a, b){


  if (a !== A) {
  //16 bit add/adc  - use separate ALU call because status flags will be different anyway?
  }


  if (b == Immediate) return function(){
    REG[A] = ALU_process_8bit( op, MEM[ PC+1 ] )
    PC+=2
  }
  if (b == HL) return function(){
    REG[A] = ALU_process_8bit( readMem( op, (REG[H]<<8)+REG[L] ) );
    PC++
  }
  return function(){
    REG[A] = ALU_process_8bit( op, REG[b]);
    PC++
  }
  

}

const ADD = 1
const ADC = 2
const SUB = 3
const SBC = 4
const AND = 5
const OR  = 6
const XOR = 7
const CP  = 8
//const INC = 9
//const DEC = 10
// daa
// cpl

function ALU_process_8bit(op, b){

  var result = REG[A];
  FLAGS.N = false; // does any ALU operation leave this unchanged? daa

  switch (op){
    case ADD: 
      result += b;
      FLAGS.H = (REG[A] &(1<<4)) != (result &(1<<4))
    break;
    case ADC:
      result += b + FLAGS.C;
      FLAGS.H = (REG[A] &(1<<4)) != (result &(1<<4))
    break;
    case SUB: 
      result -= b;
      FLAGS.N = true;
      FLAGS.H = (REG[A] &(1<<4)) != (result &(1<<4))
    break;

    case CP:
      result -= b;
      FLAGS.N = true;
      FLAGS.H = (REG[A] &(1<<4)) != (result &(1<<4))
      FLAGS.Z = (result == 0)
      FLAGS.C = result > 255 || result < 0;
    return REG[A];

    case SBC:
      result -= b + FLAGS.C;
      FLAGS.N = true;
      FLAGS.H = (REG[A] &(1<<4)) != (result &(1<<4))
    break;
    case AND:
      result &= b;
      FLAGS.H = true
    break;
    case OR:
      result |= b;
      FLAGS.H = false
    break;
    case XOR: 
      result ^= b;
      FLAGS.H = false
    break;

  }

  FLAGS.Z = (result == 0)
  FLAGS.C = result > 255 || result < 0;

  return result&0xFF;
}

function inc(a){return incdec(a, 1)}
function dec(a){return incdec(a, -1)}

function incdec(r,offset) {
  if (r==HL) return function(){
    writeMem((REG[H]<<8)+REG[L], incdec_process_8bit( readMem( (REG[H]<<8)+REG[L] ) ,offset))
    PC++
  }

  return function(){
    REG[r]=incdec_process_8bit(REG[r],offset)
    PC++
  }
}

function incdec_process_8bit(a,offset) {
    var result = a+offset;
    FLAGS.H = (a &(1<<4)) != (result &(1<<4));
    FLAGS.N = false;
    FLAGS.Z = (result == 0)
    return result;
}

// 16 bit inc / dec affect no flags
function inc16(a,b) {
  if (a==SPr) return function(){
    SP++
    PC++
  }
  return function(){
    if (REG[b] ==255) REG[a]++;
    REG[b]++;
    PC++;
  }
}
function dec16(a,b) {
  if (a==SPr) return function(){
    SP--
    PC++
  }
  return function(){
    if (REG[b] ==0) REG[a]--;
    REG[b]--;
    PC++;
  }
}

function signedOffset(b){
  return (b>127)? (b-254) : b;
}

function jrNZ(){
  if (FLAGS.Z) PC+=2
  else PC += signedOffset(MEM[PC+1])
}

function jrNC(){
  if (FLAGS.C) PC+=2
  else PC += signedOffset(MEM[PC+1])
}

function jrZ(){
  if (FLAGS.Z) PC += signedOffset(MEM[PC+1])
  else PC+=2
}

function jrC(){
  if (FLAGS.C) PC += signedOffset(MEM[PC+1])
  else PC+=2
}

function jr(){ //unconditional relative
  PC += signedOffset(MEM[PC+1])
}

function jp(){ //unconditional absolute
  PC = MEM[PC+1]+(MEM[PC+2]<<8)
}
function jpNZ(){
  if (FLAGS.Z) PC+=3
  else PC = MEM[PC+1]+(MEM[PC+2]<<8)
}
function jpNC(){
  if (FLAGS.C) PC+=3
  else PC = MEM[PC+1]+(MEM[PC+2]<<8)
}
function jpZ(){
  if (FLAGS.Z) PC = MEM[PC+1]+(MEM[PC+2]<<8)
  else PC+=3
}
function jpC(){
  if (FLAGS.C) PC = MEM[PC+1]+(MEM[PC+2]<<8)
  else PC+=3
}

function jpHL(){
  PC = (REG[H]<<8)+REG[L]
}

function push(a,b) {
  if (a==A) return function(){
    var flags = (FLAGS.Z << 7) + (FLAGS.N << 6) + (FLAGS.H << 5) + (FLAGS.C << 4)
    SP -=2
    writeMem16(SP, REG[A], flags)
    PC++
  }
  return function(){
    SP-=2
    writeMem16(SP, REG[a], REG[b])
    PC++
  }
}

function pop(a,b) {
  if (a==A) return function(){
    var s = readMem16(SP);
    REG[A] = s[0]
    FLAGS.Z = s[1] & (1<<7) == 1
    FLAGS.N = s[1] & (1<<6) == 1
    FLAGS.H = s[1] & (1<<5) == 1
    FLAGS.C = s[1] & (1<<4) == 1
    SP+=2
    PC++
  }
  return function(){
    var s = readMem16(SP);
    REG[a] = s[0]
    REG[b] = s[1]
    SP+=2
    PC++
  }
}

function call(){
  SP -=2
  var npc = PC+3
  writeMem16(SP, npc>>8, npc&0xFF)
  PC = MEM[PC+1]+(MEM[PC+2]<<8)
}
function callNZ(){
  if (FLAGS.Z) PC+=3
  else call()
}
function callNC(){
  if (FLAGS.C) PC+=3
  else call()
}
function callZ(){
  if (FLAGS.Z) call()
  else PC+=3
}
function callC(){
  if (FLAGS.C) call()
  else PC+=3
}

function ret(){
  var s = readMem16(SP);
  SP+=2
  PC = (s[0]<<8)+s[1]
}
function retNZ(){
  if (FLAGS.Z) PC++
  else ret()
}
function retNC(){
  if (FLAGS.C) PC++
  else ret()
}
function retZ(){
  if (FLAGS.Z) ret()
  else PC++
}
function retC(){
  if (FLAGS.C) ret()
  else PC++
}
function reti(){
  ret()
  EnableInterrupts = true
}

function ei(){
  EnableInterrupts = true
  PC++
}

function di(){
  EnableInterrupts = false
  PC++
}

function rst(a){
  return function(){
    SP -=2
    var npc = PC+1 // datasheets say to push the current program counter, but surely it means the return address
    writeMem16(SP, npc>>8, npc&0xFF)
    PC = a
  }
}

const RLC = 1
const RRC = 2
const RL  = 3
const RR  = 4
const SLA = 5
const SRA = 6
const SRL = 7

function shift(op, a){
  if (a==HL) return function(){
    var addr= (REG[H]<<8)+REG[L];
    writeMem( addr , shift_process( op, readMem(addr) ) )
    PC++
  }
  return function(){
    REG[a] = shift_process(op, REG[a])
    PC++
  }
}

function shift_process(op, a){

  var bit7 = a>>7, bit0 = a&1;

  switch (op) {
    case RLC: // Rotate byte left, save carry
      a = ((a<<1)&0xff) + bit7
      FLAGS.C = !!bit7
    break;
    case RRC: // Rotate byte right, save carry
      a = ((a>>1)&0xff) + (bit0<<7)
      FLAGS.C = !!bit0
    break;
    case RL : //Rotate left through carry
      a = ((a<<1)&0xff) + FLAGS.C 
      FLAGS.C = !!bit7
    break;
    case RR : //Rotate right through carry
      a = ((a>>1)&0xff) + (FLAGS.C<<7)
      FLAGS.C = !!bit0
    break;
    case SLA: //Shift left
      a = ((a<<1)&0xff)
      FLAGS.C = !!bit7
    break;
    case SRA: //Shift right arithmetic
      a = ((a>>1)&0xff) + (bit7<<7)
      FLAGS.C = !!bit0
    break;
    case SRL: //Shift right logical
      a = ((a>>1)&0xff)
      FLAGS.C = !!bit0
    break;
  }

  FLAGS.N=false
  FLAGS.H=false
  FLAGS.Z= a==0
  return a
}

function ccf(){
  FLAGS.N =false
  FLAGS.H =false
  FLAGS.C =!FLAGS.C
  PC++
}
function scf(){
  FLAGS.N =false
  FLAGS.H =false
  FLAGS.C =true
  PC++
}



const unused = function(){}; //GMB locks when called

opcodes[ 0x00 ] = function nop(){ PC++ };
opcodes[ 0x01 ] = ld16(B,C,Immediate);
opcodes[ 0x02 ] = ld_to_mem(B,C,A);
opcodes[ 0x03 ] = inc16(B,C);
opcodes[ 0x04 ] = inc(B);
opcodes[ 0x05 ] = dec(B);
opcodes[ 0x06 ] = ld(B, Immediate);
opcodes[ 0x07 ] = shift(RLC, A) //rlca
//opcodes[ 0x08 ] = ; //LD   (nn),SP
//opcodes[ 0x09 ] = ;
opcodes[ 0x0A ] = ld_from_mem(A, B, C);
opcodes[ 0x0B ] = dec16(B,C);
opcodes[ 0x0C ] = inc(C);
opcodes[ 0x0D ] = dec(C);
opcodes[ 0x0E ] = ld(C, Immediate);
opcodes[ 0x0F ] = shift(RRC, A);


//opcodes[ 0x10 ] = ; //STOP - wait for keypress
opcodes[ 0x11 ] = ld16(D,E,Immediate);
opcodes[ 0x12 ] = ld_to_mem(D,E,A);
opcodes[ 0x13 ] = inc16(D,E);
opcodes[ 0x14 ] = inc(D);
opcodes[ 0x15 ] = dec(D);
opcodes[ 0x16 ] = ld(D, Immediate);
opcodes[ 0x17 ] = shift(RL, A) 
opcodes[ 0x18 ] = jr;
//opcodes[ 0x19 ] = ; //ADD HL, DE
opcodes[ 0x1A ] = ld_from_mem(A, D, E);
opcodes[ 0x1B ] = dec16(D,E);
opcodes[ 0x1C ] = inc(E);
opcodes[ 0x1D ] = dec(E);
opcodes[ 0x1E ] = ld(E, Immediate);
opcodes[ 0x1F ] = shift(RR, A);

opcodes[ 0x20 ] = jrNZ;
opcodes[ 0x21 ] = ld16(H,L,Immediate);
opcodes[ 0x22 ] = ldi(HL,A);
opcodes[ 0x23 ] = inc16(H,L);
opcodes[ 0x24 ] = inc(H);
opcodes[ 0x25 ] = dec(H);
opcodes[ 0x26 ] = ld(H, Immediate);
//opcodes[ 0x27 ] = ; //DAA
opcodes[ 0x28 ] = jrZ;
//opcodes[ 0x29 ] = ;
opcodes[ 0x2A ] = ldi(A,HL);
opcodes[ 0x2B ] = dec16(H,L);
opcodes[ 0x2C ] = inc(L);
opcodes[ 0x2D ] = dec(L);
opcodes[ 0x2E ] = ld(L, Immediate);
//opcodes[ 0x2F ] = ;

opcodes[ 0x30 ] = jrNC;
opcodes[ 0x31 ] = ld16(SPr, Immediate);
opcodes[ 0x32 ] = ldd(HL,A);
opcodes[ 0x33 ] = inc16(SPr);
opcodes[ 0x34 ] = inc(HL);
opcodes[ 0x35 ] = dec(HL);
opcodes[ 0x36 ] = ld_to_mem(H,L,Immediate);
opcodes[ 0x37 ] = scf;
opcodes[ 0x38 ] = jrC;
//opcodes[ 0x39 ] = ;
opcodes[ 0x3A ] = ldd(A,HL);
opcodes[ 0x3B ] = dec16(SPr);
opcodes[ 0x3C ] = inc(A);
opcodes[ 0x3D ] = dec(A);
opcodes[ 0x3E ] = ld(A, Immediate);
opcodes[ 0x3F ] = ccf;


opcodes[ 0x40 ] = ld(B,B);
opcodes[ 0x41 ] = ld(B,C);
opcodes[ 0x42 ] = ld(B,D);
opcodes[ 0x43 ] = ld(B,E);
opcodes[ 0x44 ] = ld(B,H);
opcodes[ 0x45 ] = ld(B,L);
opcodes[ 0x46 ] = ld_from_mem(B, H, L );
opcodes[ 0x47 ] = ld(B,A);

opcodes[ 0x48 ] = ld(C,B);
opcodes[ 0x49 ] = ld(C,C);
opcodes[ 0x4A ] = ld(C,D);
opcodes[ 0x4B ] = ld(C,E);
opcodes[ 0x4C ] = ld(C,H);
opcodes[ 0x4D ] = ld(C,L);
opcodes[ 0x4E ] = ld_from_mem(C, H, L );
opcodes[ 0x4F ] = ld(C,A);

opcodes[ 0x50 ] = ld(D,B);
opcodes[ 0x51 ] = ld(D,C);
opcodes[ 0x52 ] = ld(D,D);
opcodes[ 0x53 ] = ld(D,E);
opcodes[ 0x54 ] = ld(D,H);
opcodes[ 0x55 ] = ld(D,L);
opcodes[ 0x56 ] = ld_from_mem(D, H, L );
opcodes[ 0x57 ] = ld(D,A);

opcodes[ 0x58 ] = ld(E,B);
opcodes[ 0x59 ] = ld(E,C);
opcodes[ 0x5A ] = ld(E,D);
opcodes[ 0x5B ] = ld(E,E);
opcodes[ 0x5C ] = ld(E,H);
opcodes[ 0x5D ] = ld(E,L);
opcodes[ 0x5E ] = ld_from_mem(E, H, L );
opcodes[ 0x5F ] = ld(E,A);

opcodes[ 0x60 ] = ld(H,B);
opcodes[ 0x61 ] = ld(H,C);
opcodes[ 0x62 ] = ld(H,D);
opcodes[ 0x63 ] = ld(H,E);
opcodes[ 0x64 ] = ld(H,H);
opcodes[ 0x65 ] = ld(H,L);
opcodes[ 0x66 ] = ld_from_mem(H, H, L );
opcodes[ 0x67 ] = ld(H,A);

opcodes[ 0x68 ] = ld(L,B);
opcodes[ 0x69 ] = ld(L,C);
opcodes[ 0x6A ] = ld(L,D);
opcodes[ 0x6B ] = ld(L,E);
opcodes[ 0x6C ] = ld(L,H);
opcodes[ 0x6D ] = ld(L,L);
opcodes[ 0x6E ] = ld_from_mem(L, H, L );
opcodes[ 0x6F ] = ld(L,A);

opcodes[ 0x70 ] = ld_to_mem(H,L, B);
opcodes[ 0x71 ] = ld_to_mem(H,L, C);
opcodes[ 0x72 ] = ld_to_mem(H,L, D);
opcodes[ 0x73 ] = ld_to_mem(H,L, E);
opcodes[ 0x74 ] = ld_to_mem(H,L, H);
opcodes[ 0x75 ] = ld_to_mem(H,L, L);
opcodes[ 0x76 ] = function halt() {}; // if interrupts disabled, stall 1 cycle, skip next instruction and continue
opcodes[ 0x77 ] = ld_to_mem(H,L, A);

opcodes[ 0x78 ] = ld(A,B);
opcodes[ 0x79 ] = ld(A,C);
opcodes[ 0x7A ] = ld(A,D);
opcodes[ 0x7B ] = ld(A,E);
opcodes[ 0x7C ] = ld(A,H);
opcodes[ 0x7D ] = ld(A,L);
opcodes[ 0x7E ] = ld_from_mem(A, H, L );
opcodes[ 0x7F ] = ld(A,A);

opcodes[ 0x80 ] = ALU(ADD,A,B);
opcodes[ 0x81 ] = ALU(ADD,A,C);
opcodes[ 0x82 ] = ALU(ADD,A,D);
opcodes[ 0x83 ] = ALU(ADD,A,E);
opcodes[ 0x84 ] = ALU(ADD,A,H);
opcodes[ 0x85 ] = ALU(ADD,A,L);
opcodes[ 0x86 ] = ALU(ADD,A, HL );
opcodes[ 0x87 ] = ALU(ADD,A,A);

opcodes[ 0x88 ] = ALU(ADC,A,B);
opcodes[ 0x89 ] = ALU(ADC,A,C);
opcodes[ 0x8A ] = ALU(ADC,A,D);
opcodes[ 0x8B ] = ALU(ADC,A,E);
opcodes[ 0x8C ] = ALU(ADC,A,H);
opcodes[ 0x8D ] = ALU(ADC,A,L);
opcodes[ 0x8E ] = ALU(ADC,A, HL );
opcodes[ 0x8F ] = ALU(ADC,A,A);

opcodes[ 0x90 ] = ALU(SUB,A,B);
opcodes[ 0x91 ] = ALU(SUB,A,C);
opcodes[ 0x92 ] = ALU(SUB,A,D);
opcodes[ 0x93 ] = ALU(SUB,A,E);
opcodes[ 0x94 ] = ALU(SUB,A,H);
opcodes[ 0x95 ] = ALU(SUB,A,L);
opcodes[ 0x96 ] = ALU(SUB,A, HL );
opcodes[ 0x97 ] = ALU(SUB,A,A);

opcodes[ 0x98 ] = ALU(SBC,A,B);
opcodes[ 0x99 ] = ALU(SBC,A,C);
opcodes[ 0x9A ] = ALU(SBC,A,D);
opcodes[ 0x9B ] = ALU(SBC,A,E);
opcodes[ 0x9C ] = ALU(SBC,A,H);
opcodes[ 0x9D ] = ALU(SBC,A,L);
opcodes[ 0x9E ] = ALU(SBC,A, HL );
opcodes[ 0x9F ] = ALU(SBC,A,A);

opcodes[ 0xA0 ] = ALU(AND,A,B);
opcodes[ 0xA1 ] = ALU(AND,A,C);
opcodes[ 0xA2 ] = ALU(AND,A,D);
opcodes[ 0xA3 ] = ALU(AND,A,E);
opcodes[ 0xA4 ] = ALU(AND,A,H);
opcodes[ 0xA5 ] = ALU(AND,A,L);
opcodes[ 0xA6 ] = ALU(AND,A, HL );
opcodes[ 0xA7 ] = ALU(AND,A,A);

opcodes[ 0xA8 ] = ALU(XOR,A,B);
opcodes[ 0xA9 ] = ALU(XOR,A,C);
opcodes[ 0xAA ] = ALU(XOR,A,D);
opcodes[ 0xAB ] = ALU(XOR,A,E);
opcodes[ 0xAC ] = ALU(XOR,A,H);
opcodes[ 0xAD ] = ALU(XOR,A,L);
opcodes[ 0xAE ] = ALU(XOR,A, HL );
opcodes[ 0xAF ] = ALU(XOR,A,A);

opcodes[ 0xB0 ] = ALU(OR,A,B);
opcodes[ 0xB1 ] = ALU(OR,A,C);
opcodes[ 0xB2 ] = ALU(OR,A,D);
opcodes[ 0xB3 ] = ALU(OR,A,E);
opcodes[ 0xB4 ] = ALU(OR,A,H);
opcodes[ 0xB5 ] = ALU(OR,A,L);
opcodes[ 0xB6 ] = ALU(OR,A, HL );
opcodes[ 0xB7 ] = ALU(OR,A,A);

opcodes[ 0xB8 ] = ALU(CP,A,B);
opcodes[ 0xB9 ] = ALU(CP,A,C);
opcodes[ 0xBA ] = ALU(CP,A,D);
opcodes[ 0xBB ] = ALU(CP,A,E);
opcodes[ 0xBC ] = ALU(CP,A,H);
opcodes[ 0xBD ] = ALU(CP,A,L);
opcodes[ 0xBE ] = ALU(CP,A, HL );
opcodes[ 0xBF ] = ALU(CP,A,A);

opcodes[ 0xC0 ] = retNZ;
opcodes[ 0xC1 ] = pop(B,C);
opcodes[ 0xC2 ] = jpNZ;
opcodes[ 0xC3 ] = jp;
opcodes[ 0xC4 ] = callNZ;
opcodes[ 0xC5 ] = push(B,C);
opcodes[ 0xC6 ] = ALU(ADD,A,Immediate);
opcodes[ 0xC7 ] = rst(0x00);
opcodes[ 0xC8 ] = retZ;
opcodes[ 0xC9 ] = ret;
opcodes[ 0xCA ] = jpZ;
opcodes[ 0xCB ] = function(){ CBcodes[ MEM[ ++PC ] ](); }
opcodes[ 0xCC ] = callZ;
opcodes[ 0xCD ] = call;
opcodes[ 0xCE ] = ALU(ADC,A,Immediate);
opcodes[ 0xCF ] = rst(0x08);

opcodes[ 0xD0 ] = retNC;
opcodes[ 0xD1 ] = pop(D,E);
opcodes[ 0xD2 ] = jpNC;
opcodes[ 0xD3 ] = unused;
opcodes[ 0xD4 ] = callNC;
opcodes[ 0xD5 ] = push(D,E);
opcodes[ 0xD6 ] = ALU(SUB,A,Immediate);
opcodes[ 0xD7 ] = rst(0x10);
opcodes[ 0xD8 ] = retC;
opcodes[ 0xD9 ] = reti; //RETI
opcodes[ 0xDA ] = jpC;
opcodes[ 0xDB ] = unused;
opcodes[ 0xDC ] = callC;
opcodes[ 0xDD ] = unused;
opcodes[ 0xDE ] = ALU(SBC,A,Immediate);
opcodes[ 0xDF ] = rst(0x18);

opcodes[ 0xE0 ] = ldh(Immediate, A); //LD   (FF00+n),A
opcodes[ 0xE1 ] = pop(H,L);
opcodes[ 0xE2 ] = ldc(C, A); //LD   (FF00+C),A
opcodes[ 0xE3 ] = unused;
opcodes[ 0xE4 ] = unused;
opcodes[ 0xE5 ] = push(H,L);
opcodes[ 0xE6 ] = ALU(AND,A,Immediate);
opcodes[ 0xE7 ] = rst(0x20);
//opcodes[ 0xE8 ] = ; //ADD  SP,dd
opcodes[ 0xE9 ] = jpHL;
opcodes[ 0xEA ] = ld_to_mem(Immediate, A); //LD   (nn),A
opcodes[ 0xEB ] = unused;
opcodes[ 0xEC ] = unused;
opcodes[ 0xED ] = unused;
opcodes[ 0xEE ] = ALU(XOR,A,Immediate);
opcodes[ 0xEF ] = rst(0x28);

opcodes[ 0xF0 ] = ldh(A, Immediate); //LD   A,(FF00+n)
opcodes[ 0xF1 ] = pop(A,FLAGS);
opcodes[ 0xF2 ] =  ldc(A, C); //LD   A,(FF00+C)
opcodes[ 0xF3 ] = di;
opcodes[ 0xF4 ] = unused;
opcodes[ 0xF5 ] = push(A, FLAGS);
opcodes[ 0xF6 ] = ALU(OR,A,Immediate);
opcodes[ 0xF7 ] = rst(0x30);
//opcodes[ 0xF8 ] = ; //LD   HL,SP+dd
opcodes[ 0xF9 ] = ld16();
opcodes[ 0xFA ] = ld_from_mem(A, Immediate); //LD   A,(nn)
opcodes[ 0xFB ] = ei;
opcodes[ 0xFC ] = unused;
opcodes[ 0xFD ] = unused;
opcodes[ 0xFE ] = ALU(CP,A,Immediate);
opcodes[ 0xFF ] = rst(0x38);








CBcodes[ 0x00 ] = shift(RLC, B);
CBcodes[ 0x01 ] = shift(RLC, C);
CBcodes[ 0x02 ] = shift(RLC, D);
CBcodes[ 0x03 ] = shift(RLC, E);
CBcodes[ 0x04 ] = shift(RLC, H);
CBcodes[ 0x05 ] = shift(RLC, L);
CBcodes[ 0x06 ] = shift(RLC, HL );
CBcodes[ 0x07 ] = shift(RLC, A);
CBcodes[ 0x08 ] = shift(RRC, B);
CBcodes[ 0x09 ] = shift(RRC, C);
CBcodes[ 0x0A ] = shift(RRC, D);
CBcodes[ 0x0B ] = shift(RRC, E);
CBcodes[ 0x0C ] = shift(RRC, H);
CBcodes[ 0x0D ] = shift(RRC, L);
CBcodes[ 0x0E ] = shift(RRC, HL );
CBcodes[ 0x0F ] = shift(RRC, A);

CBcodes[ 0x10 ] = shift(RL, B);
CBcodes[ 0x11 ] = shift(RL, C);
CBcodes[ 0x12 ] = shift(RL, D);
CBcodes[ 0x13 ] = shift(RL, E);
CBcodes[ 0x14 ] = shift(RL, H);
CBcodes[ 0x15 ] = shift(RL, L);
CBcodes[ 0x16 ] = shift(RL, HL );
CBcodes[ 0x17 ] = shift(RL, A);
CBcodes[ 0x18 ] = shift(RR, B);
CBcodes[ 0x19 ] = shift(RR, C);
CBcodes[ 0x1A ] = shift(RR, D);
CBcodes[ 0x1B ] = shift(RR, E);
CBcodes[ 0x1C ] = shift(RR, H);
CBcodes[ 0x1D ] = shift(RR, L);
CBcodes[ 0x1E ] = shift(RR, HL );
CBcodes[ 0x1F ] = shift(RR, A);

CBcodes[ 0x20 ] = shift(SLA, B);
CBcodes[ 0x21 ] = shift(SLA, C);
CBcodes[ 0x22 ] = shift(SLA, D);
CBcodes[ 0x23 ] = shift(SLA, E);
CBcodes[ 0x24 ] = shift(SLA, H);
CBcodes[ 0x25 ] = shift(SLA, L);
CBcodes[ 0x26 ] = shift(SLA, HL );
CBcodes[ 0x27 ] = shift(SLA, A);
CBcodes[ 0x28 ] = shift(SRA, B);
CBcodes[ 0x29 ] = shift(SRA, C);
CBcodes[ 0x2A ] = shift(SRA, D);
CBcodes[ 0x2B ] = shift(SRA, E);
CBcodes[ 0x2C ] = shift(SRA, H);
CBcodes[ 0x2D ] = shift(SRA, L);
CBcodes[ 0x2E ] = shift(SRA, HL );
CBcodes[ 0x2F ] = shift(SRA, A);

CBcodes[ 0x38 ] = shift(SRL, B);
CBcodes[ 0x39 ] = shift(SRL, C);
CBcodes[ 0x3A ] = shift(SRL, D);
CBcodes[ 0x3B ] = shift(SRL, E);
CBcodes[ 0x3C ] = shift(SRL, H);
CBcodes[ 0x3D ] = shift(SRL, L);
CBcodes[ 0x3E ] = shift(SRL, HL );
CBcodes[ 0x3F ] = shift(SRL, A);




function swap(r){
  if (r==HL) return function(){
    var a = readMem( (REG[H]<<8)+REG[L] );
    a = (a>>4) + ((a<<4)&0xFF);
    writeMem( (REG[H]<<8)+REG[L] , a ); 
    FLAGS.Z = (a==0)
    FLAGS.N =false
    FLAGS.H =false
    FLAGS.C =false
    PC++
  }
  return function (){
    REG[r] = (REG[r]>>4) + ((REG[r]<<4)&0xFF)
    FLAGS.Z = (REG[r]==0)
    FLAGS.N =false
    FLAGS.H =false
    FLAGS.C =false
    PC++
  }
}

CBcodes[ 0x30 ] = swap(B);
CBcodes[ 0x31 ] = swap(C);
CBcodes[ 0x32 ] = swap(D);
CBcodes[ 0x33 ] = swap(E);
CBcodes[ 0x34 ] = swap(H);
CBcodes[ 0x35 ] = swap(L);
CBcodes[ 0x36 ] = swap(HL);
CBcodes[ 0x37 ] = swap(A);

function bit(b, r) {
  b = (1<<b);

  if (r==HL) return function(){
    FLAGS.Z = ((readMem((REG[H]<<8)+REG[L]) & b) == 0)
    FLAGS.H = true;
    FLAGS.N = false;
    PC++
  }
  return function(){
    FLAGS.Z = ((REG[r] & b) == 0)
    FLAGS.H = true;
    FLAGS.N = false;
    PC++
  }
}
function set(b, r) {
  b = (1<<b);

  if (r==HL) return function(){
    writeMem(
      (REG[H]<<8)+REG[L],
      readMem((REG[H]<<8)+REG[L]) | b
    )
    PC++
  }
  return function(){
    REG[r] |= b
    PC++
  }
}
function res(b, r) {
  b = ~(1<<b);

  if (r==HL) return function(){
    writeMem(
      (REG[H]<<8)+REG[L],
      readMem((REG[H]<<8)+REG[L]) & b
    )
    PC++
  }
  return function(){
    REG[r] &= b
    PC++
  }
}

for (var i=0;i<8;i++){
  for (var j=0;j<8;j++) {
    CBcodes[ 0x40 + i*8 + j ] = bit(i, j);
    CBcodes[ 0x80 + i*8 + j ] = res(i, j);
    CBcodes[ 0xC0 + i*8 + j ] = set(i, j);
  }
}



bootCode = "31 FE FF AF 21 FF 9F 32 CB 7C 20 FB 21 26 FF 0E 11 3E 80 32 E2 0C 3E F3 E2 32 3E 77 77 3E FC E0 47 11 04 01 21 10 80 1A CD 95 00 CD 96 00 13 7B FE 34 20 F3 11 D8 00 06 08 1A 13 22 23 05 20 F9 3E 19 EA 10 99 21 2F 99 0E 0C 3D 28 08 32 0D 20 F9 2E 0F 18 F3 67 3E 64 57 E0 42 3E 91 E0 40 04 1E 02 0E 0C F0 44 FE 90 20 FA 0D 20 F7 1D 20 F2 0E 13 24 7C 1E 83 FE 62 28 06 1E C1 FE 64 20 06 7B E2 0C 3E 87 E2 F0 42 90 E0 42 15 20 D2 05 20 4F 16 20 18 CB 4F 06 04 C5 CB 11 17 C1 CB 11 17 05 20 F5 22 23 22 23 C9 CE ED 66 66 CC 0D 00 0B 03 73 00 83 00 0C 00 0D 00 08 11 1F 88 89 00 0E DC CC 6E E6 DD DD D9 99 BB BB 67 63 6E 0E EC CC DD DC 99 9F BB B9 33 3E 3C 42 B9 A5 B9 A5 42 3C 21 04 01 11 A8 00 1A 13 BE 20 FE 23 7D FE 34 20 F5 06 19 78 86 23 05 20 FB 86 20 FE 3E 01 E0 50".split(" ")


//testProg = "3E 55 06 0F A0 D6 01 20 FB 3E 55".split(" ")
//testProg = "3E 55 17 C2 02 00".split(" ")

testProg = bootCode

for (var i=0;i< testProg.length; i++) MEM[i]=parseInt(testProg[i],16);







function cpu(){

for (var i=1000;i--;)
  opcodes[ MEM[ PC ] ]();

  debugData();
}



(debugData=function(){
  function f(a,l) {return ("0000"+a.toString(16).toUpperCase()).slice(-l||-2)}

  var debug = "Mem: ";
  for (var j=0;j<8;j++) {
    for (var i=0;i<32;i++) 
      debug+= PC==(i+j*32) ? "<span style='color:red'>"+f(MEM[(i+j*32)])+"</span> ": f(MEM[(i+j*32)]) + " ";
    debug+="\n     "
  }
  debug+="\n\nPC: "+ f(PC,4)
  debug+="\n\nSP: "+ f(SP,4)
  debug+="\n\nFlags\nZ: "+FLAGS.Z+"\nN: "+FLAGS.N+"\nH: "+FLAGS.N+"\nC: "+FLAGS.C+"\n"
  
  debug+="\nA: "+ f(REG[A])
  debug+="\nB: "+ f(REG[B])
  debug+="\nC: "+ f(REG[C])
  debug+="\nD: "+ f(REG[D])
  debug+="\nE: "+ f(REG[E])
  debug+="\nH: "+ f(REG[H])
  debug+="\nL: "+ f(REG[L])


  out.innerHTML=debug;
})();











</script>
<button onclick="cpu();return false">CPU</button>
