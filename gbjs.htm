<!doctype html><meta charset=utf-8>

<script>


const MEM = new Uint8Array(65536);

function readMem(addr){return MEM[addr];}
function writeMem(addr, data){ MEM[addr] = data;}

const REG = new Uint8Array(8);

const FLAGS = {
  Z:false,
  N:false,
  H:false,
  C:false
//  PV:false
//  S:false
}

var PC = 0

var SP = 0



const A = 0b111
const B = 0b000
const C = 0b001
const D = 0b010
const E = 0b011
const H = 0b100
const L = 0b101

const HL = 0b110

const Immediate = 99

const opcodes = Array(256);
for (var i=0;i<256;i++) opcodes[i]=function(){ throw Error("Undefined Opcode "+i )};


function ld(a,b){ 

  if (a==HL) return function(){
    writeMem( (REG[H]<<8)+REG[L] , REG[b] );
    PC++
  } 

  if (b==HL) return function(){
    REG[a] = readMem( (REG[H]<<8)+REG[L] );
    PC++
  } 

  return function(){
    REG[a] = REG[b];
    PC++
  }
}




function ALU(op, a, b){


  if (a !== A) {
  //16 bit add/adc  - use separate ALU call because status flags will be different anyway?
  }


  if (b == Immediate) return function(){
    REG[A] = ALU_process_8bit( op, MEM[ PC+1 ] )
    PC+=2
  }
  if (b == HL) return function(){
    REG[A] = ALU_process_8bit( readMem( op, (REG[H]<<8)+REG[L] ) );
    PC++
  }
  return function(){
    REG[A] = ALU_process_8bit( op, REG[b]);
    PC++
  }
  

}

const ADD = 1
const ADC = 2
const SUB = 3
const SBC = 4
const AND = 5
const OR  = 6
const XOR = 7
const CP  = 8
//const INC = 9
//const DEC = 10

function ALU_process_8bit(op, b){

  var result = REG[A];
  FLAGS.N = false; // does any ALU operation leave this unchanged?

  switch (op){
    case ADD: result += b; break;
    case ADC: result += b + FLAGS.C; break;
    case SUB: 
      result -= b;
      FLAGS.N = true;
    break;
    case SBC:
      result -= b + FLAGS.C;
      FLAGS.N = true;
    break;
    case AND: break;

  }

  // Gameboy only has four flags: Z, N, H, C
  //FLAGS.S = (result & (1<<7) !=0)
  FLAGS.Z = (result == 0)
  FLAGS.H = (REG[A] &(1<<4)) != (result &(1<<4))

  FLAGS.C = result > 255 || result < 0;


  return result&0xFF;
}


opcodes[ 0x00 ] = function nop(){ PC++ };

opcodes[ 0x01 ] = ;
opcodes[ 0x02 ] = ;
opcodes[ 0x03 ] = ;
opcodes[ 0x04 ] = ;
opcodes[ 0x05 ] = ;
opcodes[ 0x06 ] = ;
opcodes[ 0x07 ] = ;
opcodes[ 0x08 ] = ;
opcodes[ 0x09 ] = ;
opcodes[ 0x0A ] = ;
opcodes[ 0x0B ] = ;
opcodes[ 0x0C ] = ;
opcodes[ 0x0D ] = ;
opcodes[ 0x0E ] = ;
opcodes[ 0x0F ] = ;

opcodes[ 0x10 ] = ;
opcodes[ 0x11 ] = ;
opcodes[ 0x12 ] = ;
opcodes[ 0x13 ] = ;
opcodes[ 0x14 ] = ;
opcodes[ 0x15 ] = ;
opcodes[ 0x16 ] = ;
opcodes[ 0x17 ] = ;
opcodes[ 0x18 ] = ;
opcodes[ 0x19 ] = ;
opcodes[ 0x1A ] = ;
opcodes[ 0x1B ] = ;
opcodes[ 0x1C ] = ;
opcodes[ 0x1D ] = ;
opcodes[ 0x1E ] = ;
opcodes[ 0x1F ] = ;

opcodes[ 0x20 ] = ;
opcodes[ 0x21 ] = ;
opcodes[ 0x22 ] = ;
opcodes[ 0x23 ] = ;
opcodes[ 0x24 ] = ;
opcodes[ 0x25 ] = ;
opcodes[ 0x26 ] = ;
opcodes[ 0x27 ] = ;
opcodes[ 0x28 ] = ;
opcodes[ 0x29 ] = ;
opcodes[ 0x2A ] = ;
opcodes[ 0x2B ] = ;
opcodes[ 0x2C ] = ;
opcodes[ 0x2D ] = ;
opcodes[ 0x2E ] = ;
opcodes[ 0x2F ] = ;

opcodes[ 0x30 ] = ;
opcodes[ 0x31 ] = ;
opcodes[ 0x32 ] = ;
opcodes[ 0x33 ] = ;
opcodes[ 0x34 ] = ;
opcodes[ 0x35 ] = ;
opcodes[ 0x36 ] = ;
opcodes[ 0x37 ] = ;
opcodes[ 0x38 ] = ;
opcodes[ 0x39 ] = ;
opcodes[ 0x3A ] = ;
opcodes[ 0x3B ] = ;
opcodes[ 0x3C ] = ;
opcodes[ 0x3D ] = ;
opcodes[ 0x3E ] = ;
opcodes[ 0x3F ] = ;


opcodes[ 0x40 ] = ld(B,B);
opcodes[ 0x41 ] = ld(B,C);
opcodes[ 0x42 ] = ld(B,D);
opcodes[ 0x43 ] = ld(B,E);
opcodes[ 0x44 ] = ld(B,H);
opcodes[ 0x45 ] = ld(B,L);
opcodes[ 0x46 ] = ld(B, HL );
opcodes[ 0x47 ] = ld(B,A);

opcodes[ 0x48 ] = ld(C,B);
opcodes[ 0x49 ] = ld(C,C);
opcodes[ 0x4A ] = ld(C,D);
opcodes[ 0x4B ] = ld(C,E);
opcodes[ 0x4C ] = ld(C,H);
opcodes[ 0x4D ] = ld(C,L);
opcodes[ 0x4E ] = ld(C, HL );
opcodes[ 0x4F ] = ld(C,A);

opcodes[ 0x50 ] = ld(D,B);
opcodes[ 0x51 ] = ld(D,C);
opcodes[ 0x52 ] = ld(D,D);
opcodes[ 0x53 ] = ld(D,E);
opcodes[ 0x54 ] = ld(D,H);
opcodes[ 0x55 ] = ld(D,L);
opcodes[ 0x56 ] = ld(D, HL );
opcodes[ 0x57 ] = ld(D,A);

opcodes[ 0x58 ] = ld(E,B);
opcodes[ 0x59 ] = ld(E,C);
opcodes[ 0x5A ] = ld(E,D);
opcodes[ 0x5B ] = ld(E,E);
opcodes[ 0x5C ] = ld(E,H);
opcodes[ 0x5D ] = ld(E,L);
opcodes[ 0x5E ] = ld(E, HL );
opcodes[ 0x5F ] = ld(E,A);

opcodes[ 0x60 ] = ld(H,B);
opcodes[ 0x61 ] = ld(H,C);
opcodes[ 0x62 ] = ld(H,D);
opcodes[ 0x63 ] = ld(H,E);
opcodes[ 0x64 ] = ld(H,H);
opcodes[ 0x65 ] = ld(H,L);
opcodes[ 0x66 ] = ld(H, HL );
opcodes[ 0x67 ] = ld(H,A);

opcodes[ 0x68 ] = ld(L,B);
opcodes[ 0x69 ] = ld(L,C);
opcodes[ 0x6A ] = ld(L,D);
opcodes[ 0x6B ] = ld(L,E);
opcodes[ 0x6C ] = ld(L,H);
opcodes[ 0x6D ] = ld(L,L);
opcodes[ 0x6E ] = ld(L, HL );
opcodes[ 0x6F ] = ld(L,A);

opcodes[ 0x70 ] = ld(HL, B);
opcodes[ 0x71 ] = ld(HL, C);
opcodes[ 0x72 ] = ld(HL, D);
opcodes[ 0x73 ] = ld(HL, E);
opcodes[ 0x74 ] = ld(HL, H);
opcodes[ 0x75 ] = ld(HL, L);
opcodes[ 0x76 ] = function halt() {}; // if interrupts disabled, stall 1 cycle, skip next instruction and continue
opcodes[ 0x77 ] = ld(HL, A);

opcodes[ 0x78 ] = ld(A,B);
opcodes[ 0x79 ] = ld(A,C);
opcodes[ 0x7A ] = ld(A,D);
opcodes[ 0x7B ] = ld(A,E);
opcodes[ 0x7C ] = ld(A,H);
opcodes[ 0x7D ] = ld(A,L);
opcodes[ 0x7E ] = ld(A, HL );
opcodes[ 0x7F ] = ld(A,A);

opcodes[ 0x80 ] = ALU(ADD,A,B);
opcodes[ 0x81 ] = ALU(ADD,A,C);
opcodes[ 0x82 ] = ALU(ADD,A,D);
opcodes[ 0x83 ] = ALU(ADD,A,E);
opcodes[ 0x84 ] = ALU(ADD,A,H);
opcodes[ 0x85 ] = ALU(ADD,A,L);
opcodes[ 0x86 ] = ALU(ADD,A, HL );
opcodes[ 0x87 ] = ALU(ADD,A,A);

opcodes[ 0x88 ] = ALU(ADC,A,B);
opcodes[ 0x89 ] = ALU(ADC,A,C);
opcodes[ 0x8A ] = ALU(ADC,A,D);
opcodes[ 0x8B ] = ALU(ADC,A,E);
opcodes[ 0x8C ] = ALU(ADC,A,H);
opcodes[ 0x8D ] = ALU(ADC,A,L);
opcodes[ 0x8E ] = ALU(ADC,A, HL );
opcodes[ 0x8F ] = ALU(ADC,A,A);

opcodes[ 0x90 ] = ALU(SUB,A,B);
opcodes[ 0x91 ] = ALU(SUB,A,C);
opcodes[ 0x92 ] = ALU(SUB,A,D);
opcodes[ 0x93 ] = ALU(SUB,A,E);
opcodes[ 0x94 ] = ALU(SUB,A,H);
opcodes[ 0x95 ] = ALU(SUB,A,L);
opcodes[ 0x96 ] = ALU(SUB,A, HL );
opcodes[ 0x97 ] = ALU(SUB,A,A);

opcodes[ 0x98 ] = ALU(SBC,A,B);
opcodes[ 0x99 ] = ALU(SBC,A,C);
opcodes[ 0x9A ] = ALU(SBC,A,D);
opcodes[ 0x9B ] = ALU(SBC,A,E);
opcodes[ 0x9C ] = ALU(SBC,A,H);
opcodes[ 0x9D ] = ALU(SBC,A,L);
opcodes[ 0x9E ] = ALU(SBC,A, HL );
opcodes[ 0x9F ] = ALU(SBC,A,A);

opcodes[ 0xA0 ] = ALU(AND,A,B);
opcodes[ 0xA1 ] = ALU(AND,A,C);
opcodes[ 0xA2 ] = ALU(AND,A,D);
opcodes[ 0xA3 ] = ALU(AND,A,E);
opcodes[ 0xA4 ] = ALU(AND,A,H);
opcodes[ 0xA5 ] = ALU(AND,A,L);
opcodes[ 0xA6 ] = ALU(AND,A, HL );
opcodes[ 0xA7 ] = ALU(AND,A,A);

opcodes[ 0xA8 ] = ALU(XOR,A,B);
opcodes[ 0xA9 ] = ALU(XOR,A,C);
opcodes[ 0xAA ] = ALU(XOR,A,D);
opcodes[ 0xAB ] = ALU(XOR,A,E);
opcodes[ 0xAC ] = ALU(XOR,A,H);
opcodes[ 0xAD ] = ALU(XOR,A,L);
opcodes[ 0xAE ] = ALU(XOR,A, HL );
opcodes[ 0xAF ] = ALU(XOR,A,A);

opcodes[ 0xB0 ] = ALU(OR,A,B);
opcodes[ 0xB1 ] = ALU(OR,A,C);
opcodes[ 0xB2 ] = ALU(OR,A,D);
opcodes[ 0xB3 ] = ALU(OR,A,E);
opcodes[ 0xB4 ] = ALU(OR,A,H);
opcodes[ 0xB5 ] = ALU(OR,A,L);
opcodes[ 0xB6 ] = ALU(OR,A, HL );
opcodes[ 0xB7 ] = ALU(OR,A,A);

opcodes[ 0xB8 ] = ALU(CP,A,B);
opcodes[ 0xB9 ] = ALU(CP,A,C);
opcodes[ 0xBA ] = ALU(CP,A,D);
opcodes[ 0xBB ] = ALU(CP,A,E);
opcodes[ 0xBC ] = ALU(CP,A,H);
opcodes[ 0xBD ] = ALU(CP,A,L);
opcodes[ 0xBE ] = ALU(CP,A, HL );
opcodes[ 0xBF ] = ALU(CP,A,A);

opcodes[ 0xC0 ] = ;
opcodes[ 0xC1 ] = ;
opcodes[ 0xC2 ] = ;
opcodes[ 0xC3 ] = ;
opcodes[ 0xC4 ] = ;
opcodes[ 0xC5 ] = ;
opcodes[ 0xC6 ] = ALU(ADD,A,Immediate);
opcodes[ 0xC7 ] = ;
opcodes[ 0xC8 ] = ;
opcodes[ 0xC9 ] = ;
opcodes[ 0xCA ] = ;
opcodes[ 0xCB ] = ;
opcodes[ 0xCC ] = ;
opcodes[ 0xCD ] = ;
opcodes[ 0xCE ] = ALU(ADC,A,Immediate);
opcodes[ 0xCF ] = ;

opcodes[ 0xD0 ] = ;
opcodes[ 0xD1 ] = ;
opcodes[ 0xD2 ] = ;
opcodes[ 0xD3 ] = ;
opcodes[ 0xD4 ] = ;
opcodes[ 0xD5 ] = ;
opcodes[ 0xD6 ] = ALU(SUB,A,Immediate);
opcodes[ 0xD7 ] = ;
opcodes[ 0xD8 ] = ;
opcodes[ 0xD9 ] = ;
opcodes[ 0xDA ] = ;
opcodes[ 0xDB ] = ;
opcodes[ 0xDC ] = ;
opcodes[ 0xDD ] = ;
opcodes[ 0xDE ] = ALU(SBC,A,Immediate);
opcodes[ 0xDF ] = ;

opcodes[ 0xE0 ] = ;
opcodes[ 0xE1 ] = ;
opcodes[ 0xE2 ] = ;
opcodes[ 0xE3 ] = ;
opcodes[ 0xE4 ] = ;
opcodes[ 0xE5 ] = ;
opcodes[ 0xE6 ] = ;
opcodes[ 0xE7 ] = ;
opcodes[ 0xE8 ] = ;
opcodes[ 0xE9 ] = ;
opcodes[ 0xEA ] = ;
opcodes[ 0xEB ] = ;
opcodes[ 0xEC ] = ;
opcodes[ 0xED ] = ;
opcodes[ 0xEE ] = ;
opcodes[ 0xEF ] = ;

opcodes[ 0xF0 ] = ;
opcodes[ 0xF1 ] = ;
opcodes[ 0xF2 ] = ;
opcodes[ 0xF3 ] = ;
opcodes[ 0xF4 ] = ;
opcodes[ 0xF5 ] = ;
opcodes[ 0xF6 ] = ;
opcodes[ 0xF7 ] = ;
opcodes[ 0xF8 ] = ;
opcodes[ 0xF9 ] = ;
opcodes[ 0xFA ] = ;
opcodes[ 0xFB ] = ;
opcodes[ 0xFC ] = ;
opcodes[ 0xFD ] = ;
opcodes[ 0xFE ] = ;
opcodes[ 0xFF ] = ;






















function cpu(){

  opcodes[ MEM[ PC ] ]();

  

}















</script>
